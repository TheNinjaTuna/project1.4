Week 1 Opdracht 1 B

Bij het declareren van een variabele maak je er als het ware ruimte voor. Hierbij krijgt de variabele nog geen invulling en heeft het geen waarde; "null".
Bij het initialiseren krijgt de variabele een waarde toegewezen op de plek waar er ruimte voor is.

Week 2 Opdracht 1 A

Omdat een 'while' loop alleen maar hoeft te checken of de condition 'kassa.erIsEenRij' true is.
Als deze dat niet is voert hij ook niks uit. (Behalve de eerste check om te kijken of de condition true is)

Week 2 Opdracht 4 A

Kantine heeft een aantal methodes die niks anders doet dan dezelfde methode in de kassa object aanroepen.
Dit is dus een dubbelle methode

Week 2 Opdracht 5 A

Ten eerste is private is gewoon de standaard, daarnaast is het ook om te weten dat je deze code nergens anders buiten de class moet gebruiken. En ook omdat deze private zijn kun je deze ergens anders een method met dezelfde naam opnieuw gebruiken.
// eventueel nog extra

Week 2 Opdracht 5 B

Ze staan beide verschillende dingen toe.
Een HashSet slaat waarden op, en staat geen duplicates toe.
Buiten de context van dit project zou je hier de dagen van een week in kunnen zetten.
Deze slaat hij dan op, alleen niet op volgorde

Een HashMap heeft een key die verbonden is aan een waarde. Ook deze heeft geen volgorde.
Een HashMap kan geen duplicate keys hebben, maar wel duplicate waardes.
Je kunt deze gebruiken om twee waarden te koppelen.

Waar het op neer komt op het gebied van verschillen is dat de HashMap een key en een waarde opslaat, waarbij de waarde meerdere keren voor kan komen.
Terwijl een HashSet een enkele waarde opslaat, die maar 1 keer voor mag komen.
Een HashMap is dus eigenlijk Key+Value terwijl een HashSet alleen Key is.

Week 2 Opdracht 6 A

public KantineSimulatie() {
41 kantine = new Kantine(); //hier wordt een nieuwe kantine object aangemaakt
42 random = new Random(); // hier wordt een nieuw random object aangemaakt
43 int[] hoeveelheden = getRandomArray( // hier wordt een integer array aangemaakt en word gevult met willekeurige waarden gevult. Ook zijn er grenzen gezet met waarmee het gevult kan worden.
44 AANTAL_ARTIKELEN,
45 MIN_ARTIKELEN_PER_SOORT,
46 MAX_ARTIKELEN_PER_SOORT);
47 kantineaanbod = new KantineAanbod( //Hier wordt een kantineaanbod object gemaakt en gevuld met de voor genitialiseerde waarden.
48 artikelnamen, artikelprijzen, hoeveelheden);
49
50 kantine.setKantineAanbod(kantineaanbod) ;} //Hier word het kantineaanbod object van Kantine gekoppeld aan de net gemaakte kantineaanbod;

Week 2 Opdracht 6
random.nextInt pakt een nummer van 0 (inclusief) en een aangegeven getal (exclusief)
Wat dit wil zeggen is dat het een random getal vanaf 0 tot het aangegeven getal is, dus niet tot en MET het aangegeven getal.
De +1 zorgt ervoor dat wanneer je bijvoorbeeld het getal 50 aangeeft, hij normaal 49 zou pakken. Maar door de +1 pakt hij hier gewoon 50 (49+1).

Week 3 Opdracht 2 C
Als je geen constructor maakt dan genereert de compiller automatisch een lege constructor.


Week 3 Opdracht 2 D
Als we de twee methoden static maken dan kunnen ze worden aangeroepen vanuit een class context. Dat houd in dat je geen objectinstantie ervan nodig hebt om de functie te gebruiken.
Aangezien de methode geen gebruik maakt van niet statische variabelen kan dit gewoon veilig gebruikt worden. Maar zo gauw er iets niet statisch aan gegeven wordt krijg je een compiler error.

Week 3 Opdracht 2 E
Nu de Adminstratie's constructor private is kan een instantie van het object niet meer gemaakt worden buiten de klasse zelf.

Week 3 Opdracht 2 H
Aangezien de methode statisch is verwacht hij elke keer te werken met dezelfde klasse variabellen en hij herkent final niet als een vaste klasse-variabel omdat het niet statisch gedifineerd is.

Week 3 Opdracht 2 I
Het probleem dat we nu geintroduceerd hebben is dat de variabelle niet meer "vast staat" en dat hij perongeluk veranderd zou kunnen worden, waardoor de werking van het progamma in gevaar komt.



